% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/parse-body.R
\name{add_parser}
\alias{add_parser}
\title{Add a Parsers}
\usage{
add_parser(content_type, parser, verbose = TRUE)
}
\arguments{
\item{content_type}{A string to match against the content-type of each part of
the request body}

\item{parser}{The parser function to be added. This function should possibly
accept \code{value} and the named parameters \code{content_type} and \code{filename}.
Other parameters may be provided from \code{\link[webutils:parse_multipart]{webutils::parse_multipart()}}.
To be safe, add a \code{...} to your function signature.}

\item{verbose}{Logical value which determines if a warning should be
displayed when patterns are overwritten.}
}
\description{
A parser is responsible for decoding the raw body content of a request into
a list of arguments that can be mapped to endpoint function arguments.
For instance, the \code{parser_json} parser content-type \code{application/json}.
}
\details{
Parser function structure is something like below. Available parameters
to build parser are \code{value}, \code{content_type} and \code{filename} (only available
in \code{multipart-form} body).\if{html}{\out{<div class="r">}}\preformatted{parser <- function(value, content_type = "ct", filename, ...) \{
  # do something with raw value
\}
}\if{html}{\out{</div>}}

It should return a named list if you want values to map to
plumber endpoint function args.
}
\examples{
parser_dcf <- function(value, content_type = "text/x-dcf", ...) {
  charset <- getCharacterSet(content_type)
  value <- rawToChar(value)
  Encoding(value) <- charset
  read.dcf(value)
}
}
