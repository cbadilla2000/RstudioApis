% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/parse-body.R
\name{register_parser}
\alias{register_parser}
\alias{registered_parsers}
\alias{combine_parsers}
\title{Manage parsers}
\usage{
register_parser(alias, parser, fixed = NULL, regex = NULL, verbose = TRUE)

registered_parsers()

combine_parsers(aliases)
}
\arguments{
\item{alias}{An alias to map parser from the \verb{@parser} plumber tag to the global parsers list.}

\item{parser}{The parser function to be added. This build the parser function.}

\item{fixed}{A character vector of fixed string to be matched against a request \code{content-type} to use \code{parser}.}

\item{regex}{A character vector of \link{regex} string to be matched against a request \code{content-type} to use \code{parser}.}

\item{verbose}{Logical value which determines if a warning should be
displayed when alias in map are overwritten.}

\item{aliases}{Can be one of:
\itemize{
\item A character vector of \code{alias} names.
\item A named \code{list()} whose keysare \code{alias} names and values are arguments to be applied with \code{\link[=do.call]{do.call()}}
\item A \code{TRUE} value, which will default to combining all parsers. This is great for seeing what is possible, but not great for security purposes.
}}
}
\description{
A parser is responsible for decoding the raw body content of a request into
a list of arguments that can be mapped to endpoint function arguments.
For instance, \code{\link[=parser_json]{parser_json()}} parse content-type \code{application/json}.
}
\details{
When \code{parser} is evaluated, it should return a parser function.
Parser matching is done first by \code{content-type} header matching on \code{fixed} then by using a
regular expressions on \code{regex}. Note that plumber strip the header from \verb{; charset*} to
perform matching.

There is a special case when no \code{content-type} header is
provided that will use a \code{\link[=parser_json]{parser_json()}} when it detects a \code{json} string.

Functions signature should include \code{value}, \code{...} and
possibly \code{content_type}, \code{filename}. Other parameters may be provided
if you want to use the headers from \code{\link[webutils:parse_multipart]{webutils::parse_multipart()}}.

Parser function structure is something like below.\if{html}{\out{<div class="r">}}\preformatted{parser <- () \{
 function(value, ...) \{
  # do something with raw value
 \}
\}
}\if{html}{\out{</div>}}
}
\section{Functions}{
\itemize{
\item \code{registered_parsers}: Return all registered parsers

\item \code{combine_parsers}: Select from global parsers and create a combined parsers list for programmatic use.
}}

\examples{
# `content-type` header is mostly used to look up charset and adjust encoding
parser_dcf <- function() {
  function(value, content_type = "text/x-dcf", ...) {
    charset <- getCharacterSet(content_type)
    value <- rawToChar(value)
    Encoding(value) <- charset
    read.dcf(value)
  }
}
register_parser("dcf", parser_dcf, fixed = "text/x-dcf")
}
